---
layout: post
title: "Swim Cloud Evaluation"
excerpt: "Here is how your Internet of Things gets massive, fast"
tags: [IoT, cloud]
image:
# pic jessica nedved swimming 1900x500-c70.jpg
  feature: https://cloud.githubusercontent.com/assets/300046/16708828/1e020bc6-45bd-11e6-9b1d-efb4246989c2.jpg
  credit: Jessica Nedved
  creditlink: http://www.jessicanedved.com/blog/?p=29
comments: true
---
<i>{{ page.excerpt }}</i>
<hr />

{% include _toc.html %}

This tutorial aims to enable someone with minimal tech experience to critically evaluate the internals of
<a target="_blank" href="http://www.swim.it/">swim.it</a> 
cloud service using its sample code.

We try to make sense of confusing marketing hype and technical buzzwords 
by explaining them in context as we take it step-by-step,
with NOTEs and PROTIPs along the way.

We try to minimize the "mental gymastics" one has to do to understand a system
by carefully sequencing the commentary below.

We'll explain these buzzwords in context:

   * real-time 
   * bidirectional
   * low latency 
   * Streams
   * stateful
   * Asynch REST API
   * push network
   * persistent links subscription
   * multiplexes
   * Reactive
   * IoT
   * Global Actor Model
   * Peer-to-Peer messaging
   * SDK
   * iOS 
   * Androic
   * Scala
   
## Wiki plan #

   Transparency of progress is presented in the wiki at:<br />
   <a target="_blank" href="https://github.com/swimit/swim-examples/wiki">
   https://github.com/swimit/swim-examples/wiki</a>

   Sure, "anyone" can code this library (in a 24 hour hackathon), 
   but this team has done it
   but putting together all the other many aspects of a software development organization.
   See my list of [what a Developer Evangelist needes to consider](/evangelist/).

   The SWIM.it organization makes its money (has a "business model") 
   from charging for traffic on servers the company sets up in the cloud or on-premesis.


## Browser sample chat in the cloud #

Let's look at how the company's sample app works to see how it interacts with their SWIM cloud.

0. Use an internet browser (such as Google Chrome) to

   <a target="_blank" href="http://chat.swim.it/#/chat/public">
   http://chat.swim.it/#/chat/public</a>

   <amp-img width="324" height="103" alt="swim chat client screen 324x103-c67.jpg"
   layout="responsive" 
   src="https://cloud.githubusercontent.com/assets/300046/16707566/7fbdf866-4590-11e6-800b-371d8d3cb18c.jpg">
   </amp-img><br /><br />

   This communicates with a SWIM service running within the AWS EC2 public cloud infrastructure.

0. Click <strong>Sign In</strong> at the lower left.
0. Select your Google account in the pop-up window that appears.

   We're assuming that you have a Google account.

0. Click Allow.

   <amp-img width="650" height="297" alt="swim chat client logged in 650x297-c62.jpg"
   layout="responsive" 
   src="https://cloud.githubusercontent.com/assets/300046/16707596/ac65cbcc-4591-11e6-9d93-529dbcbc4de3.jpg">
   </amp-img><br /><br />

0. Click on a topic <strong>channel</strong> at the left, such as "Public".

0. Type a message such as "hello".

   Because this app is intended for use as a demo for developers,
   it has a UI feature that is usually not in production apps.

   NEXT: We'll be examining each of the client code fragments exposed by the sample app
   as we build our own client app running locally.

0. Click on each of the "{}" to expose client code for the major functions performed by almost all clients:

   * The lower-left {} (next to the exit icon)  exposes code for <a href="#Authenticating">Authenticating users</a>.
   * The upper-left {} (next to the EDIT icon)  exposes code for <a href="#Synchronizing">Synchronizing chat channels</a>.
   * The lower-right {} (above the Send button) exposes code for <a href="#Streaming">Streaming chat messages</a>.
   * The upper-right {} exposes code for <a href="#Tracking">Tracking user presence</a>.
   * The {} to the left of the Message entry box exposes code for <a href="#Posting">Posting a chat message</a>

<hr />

   We next examine each below:

<a name="Authenticating"></a>

### Authenticating users #

   <pre>
gapi.auth2.currentUser.listen(function (googleUser) {
  if (googleUser.isSignedIn()) {
    var idToken = googleUser.getAuthResponse().id_token;
    swim.authorize('', {googleIdToken: idToken});
  }
});
   </pre>

   Notice the "gapi" is for Google API, which returns the "googleUser" object from the JavaScript closure function.

   QUESTION: What about other Single-sign-on (SSO) such as
   GitHub, Facebook, Twitter, etc.

   "swim.authorize" stores the {googleIdToken: idToken}.


<a name="Synchronizing"></a>

### Synchronizing channels #

   <pre>
Client:
&nbsp;
var channels = swim.downlink()
  .node('')
  .lane('group/chats')
  .primaryKey(function (channel) { return channel.chatUri; })
  .onEvent(function (message) {
    // redraw UI with elements of channels.state array
  })
  .sortBy('name') // sort alphabetically by channel name
  .keepAlive(true) // reconnect after network failure
  .syncMap(); // keep state synchronized
&nbsp;
Server:
&nbsp;
var groupChats = new service.MapLane().register('group/chats'); // map from chat URIs to channel info
var chatInfo = new service.JoinLane().register('chat/info'); // aggregate chat/info streams
chatInfo.onJoinEvent = function (message, downlink) {
  // called when channel info updates
  var groupChat = groupChats.get(downlink.nodeUri) || {};
  recon.set(groupChat, 'userCount', message.body.userCount); // update present user count
  groupChats.set(downlink.nodeUri, groupChat);
};
chatInfo.onJoinLinked = function (response, downlink) {
  // called when channel added to group
};
chatInfo.onJoinClose = function (downlink) {
  // called when channel removed from group
  groupChats.delete(downlink.nodeUri);
};
   </pre>



<a name="Streaming"></a>

### Streaming messages #


   <pre>
Client:
&nbsp;
var chat = swim.downlink()
  <a href="#websockets">.node('ws://messenger.swim.services/chat/public')</a>
  <a href="#ServiceChat">.lane('chat/room')</a>
  .onEvent(function (message) {
    // redraw UI with elements of chat.state array
  })
  .keepAlive(true) // reconnect after network failure
  .syncList(); // keep state synchronized
&nbsp;
Server:
&nbsp;
var chatRoom = new service.ListLane().register('chat/room');
   </pre>


   The `swim.downlink()` coding is "down" because
   the list of channels is obtained from the server by the code.
   Downlinks are also called "outbound" from the server.

   The `ws://` in `.node('ws://messenger.swim.services/chat/public')` coding
   uses the <a href="#websockets">websockets protocol</a>
   instead of HTTP:// protocol currently common on websites.

   NOTE: The WebSockets protocol is what enables a <strong>continuously open</strong>
   channel of communication between client and server,
   which removes the time ("latency") loss from having to open a channel.
   
   Communications are kept alive also by the `.keepAlive(true)` coding
   to reconnect after network failure and
   `.syncList()` coding to keep state (status) synchronized.

   The communication is called "asynchronous".


   The `.lane('chat/room')` coding specifies the "lane" running in the server named "chat/room".
   Each "lane" is also called "event source".
   
   Several clients can communicate with each named lane.


<a name="Tracking"></a>

### Tracking user presence #

   <pre>
Client:
&nbsp;
var users = swim.downlink()
  .node('')
  .lane('chat/users')
  .primaryKey(function (user) { return user.email; })
  .onEvent(function (message) {
    // redraw UI with elements of users.state array
  })
  .keepAlive(true) // reconnect after network failure
  .syncMap(); // keep state synchronized
&nbsp;
Server:
&nbsp;
var chatUsers = new service.MapLane().register('chat/users');
var chatRoom = new service.ListLane().register('chat/room');
chatRoom.onEnter = function (user) {
  chatUsers.set(user.email, {email: user.email, name: user.name});
};
chatRoom.onLeave = function (user) {
  chatUsers.delete(user.email);
};
   </pre>

   The `new` keyword in coding `new service.ListLane().register('chat/room');`
   registers a new chat/room to the list of lanes within the chatRoom object
   maintained by the server.

   The `new` keyword in coding `new service.MapLane().register('chat/users');`
   registers a new user to the map of lane users  within the chatUsers object
   maintained by the server.

   The email of the user (obtained from Google)
   is the key to information about each user on the server.



<a name="Posting"></a>

### Posting a chat message #

   <pre>
Client:
&nbsp;
var message = {
  body: 'Hello, world!'
}
swim.command('', 'chat/room', message);
&nbsp;
Server:
&nbsp;
var chatRoom = new service.ListLane().register('chat/room');
   </pre>

   The "Hello, world!" text in the sample coding
   is replaced by whatever is typed in the Message field.


## Chat client libraries #

To get a better understanding of the actual code:

0. Alt-click on the demo chat client webpage to <strong>View source</strong>.
   The source downloaded is (rightly) minified of 
   white space and line breaks for smaller and thus quicker usage.

   In addition to the libraries unique to the app:

   * <a target="_blank" href="http://chat.swim.it/styles/app.min.css">styles/app.min.css</a> 
   based on <a target="_blank" href="https://github.com/necolas/normalize.css">
   github.com/necolas/normalize.css</a> 
   for a "modern alternative to CSS resets" that
   1) correct the line height in all browsers and 2) prevent adjustments of font size after orientation changes in IE and iOS.

   * <a target="_blank" href="http://chat.swim.it/scripts/app.min.js">scripts/app.min.js</a>
   <br /><br />

   The libraries used by the client app are:

   * <a target="_blank" href="http://chat.swim.it/scripts/modernizr.js">modernizr.js</a> (by Paul Irish)

   * <a target="_blank" href="http://chat.swim.it/scripts/jquery/jquery.min.js">jquery.min.js</a> v2.2.1 from http://jquery.com/ - https://cdnjs.com/libraries/jquery/ or https://developers.google.com/speed/libraries/

   * <a target="_blank" href="https://apis.google.com/js/platform.js">https://apis.google.com/js/platform.js</a> for Google Sign-in - see https://developers.google.com/identity/sign-in/web/sign-in

   Angular v1 from http://angularjs.org:

   * <a target="_blank" href="http://chat.swim.it/scripts/angular/angular.min.js">scripts/angular/angular.min.js</a>  v1.4.9
   * <a target="_blank" href="http://chat.swim.it/scripts/angular/angular-ui-router.min.js">scripts/angular/angular-ui-router.min.js</a> v0.2.18
   * <a target="_blank" href="http://chat.swim.it/scripts/angular/angular-animate.min.js">scripts/angular/angular-animate.min.js</a> v1.4.9 
 
   * <a target="_blank" href="http://chat.swim.it/scripts/foundation/foundation-apps.min.js">foundation-apps.min.js</a> - Angular-powered framework from <a target="_blank" href="https://github.com/zurb/foundation-apps">https://github.com/zurb/foundation-apps</a>
   (CDN versions at https://cdnjs.com/libraries/foundation)


## Build locally #

   NEXT: To get a even better understanding of the client app, let's construct it on a local machine.

0. On a Mac, a pre-requisite is to [install Homebrew](/macos-homebrew/)
   explained by <a target="_blank" href="http://computers.tutsplus.com/tutorials/homebrew-demystified-os-xs-ultimate-package-manager--mac-44884">
   this tutorial</a>.

0. Extract files from (tap) within the swim project under the swimit organization on GitHub
   as described in <a target="_blank" href="https://github.com/swimit/swimjs">
   https://github.com/swimit/swimjs</a>

   <tt><strong>
   brew tap <a target="_blank" href="https://github.com/swimit/swim/tree/master/repo">swimit/swim</a><br />
   brew install swimjs
   </strong></tt>

   This command makes use of the Ruby-language (.rb) file at
   <a target="_blank" href="https://github.com/swimit/homebrew-swim/blob/master/swimjs.rb">
   https://github.com/swimit/homebrew-swim/blob/master/swimjs.rb</a>,
   shown below:

   {% highlight text %}
class Swimjs < Formula
  desc "Swim JavaScript Runtime"
  homepage "http://www.swim.it"
  url "https://raw.githubusercontent.com/swimit/swim/master/repo/swimjs-0.1.0-alpha3.tar.gz"
  version "0.1.0-alpha3"
  sha256 "d77880795f3ab904add10de351cefe6b45fc225a5754ef29c6ce75b7892105e0"

  depends_on :java => "1.8+"

  def install
    rm_f Dir["bin/*.bat"]
    libexec.install "bin", "lib"
    bin.install_symlink Dir["#{libexec}/bin/*"]
  end
end
}{% endhighlight %}

   Note from the above:

   * The sha256 value was pre-calculated from where the file is stored before upload.
   The "hash" is based on every byte in the file.  
   The same calculation is repeated on the file after download. 
   If the output is the same, no transmission errors occurred.

   * The url of "https://raw.githubusercontent.com/swimit/swim/master/repo/swimjs-0.1.0-alpha3.tar.gz"
   is among a list of files shown on a formatted web page at<br />
   <a target="_blank" href="https://github.com/swimit/swim/tree/master/repo">
   https://github.com/swimit/swim/tree/master/repo</a>

   Neither "swimit" nor "swimjs" mentioned in the brew commands above
   are found in http://brewformulas.org/ nor
   http://braumeister.org/
   because logic for the sample client app should be 
   built alongside the server app to ensure version integrity.

   * <strong>Java 1.8+</strong> is a dependency because when the tar.gz file is expanded,
   all files in the lib folder are <strong>.jar</strong> (java archive) files.

.jar files reveal the technologies used:

   * Joda time from http://www.joda.org/joda-time/  a quality replacement for the Java date and time classes.
   * Jackson XML processor from http://wiki.fasterxml.com/JacksonHome
   * Guava Java utility library from https://github.com/google/guava
   * Apache commons-logging for Java from https://commons.apache.org/proper/commons-logging/

   * Scala language
   * Reify.it - A foundation library for Scala focussed on efficiency and clean design

   * h2 SQL database engine from http://www.h2database.com/

All these are rather standard for new development in 2016. 

Questions:

   * JUnit ?

   * NO SQL and caching such as Redis ?

   * Performance testing benchmark results?

https://github.com/swimit/swimjs/blob/master/examples/chat-presence/chat.html
   Angular
   Bootstrap

https://github.com/swimit/swimjs/blob/master/examples/chat-presence/chat.js



0. Install the Swim client using the Node.js Package Manager:

   As described in https://github.com/swimit/swim-client-js

   <tt><strong>
   npm install --save swim-client-js
   </strong></tt>


<a name="websockets"></a>

## web


<a name="ServiceChat"></a>

## Cloud service called chat #







## Architecture Diagram #





## recon JSON #

In the course of construction, SWIM developers 
created a library that has general applicability for other projects.

   require('recon-js');
   https://www.npmjs.com/package/recon-js
   Record Notation (RECON)
   RECON brings attributes into the era of object notation, and provides a simple grammar and uniform tree model for attributed text markup. RECON aims to combine the minimalism of JSON with the expressiveness of XML in a human-friendly syntax.
   https://github.com/swimit/recon-js


https://github.com/swimit/swimjs/blob/master/examples/chat-presence/swim.recon

   <pre>
@server {
  port: 5619
  store: "chat.store"
  auth: test
&nbsp;
  @route {
    prefix: "/chat/"
    service: "chat"
  }
}
&nbsp;
@service {
  name: "chat"
  main: "chat.js"
}
   </pre>

@event, @server, @service, are <strong>datatypes</strong>
described for humans in
???

@ack, @auth, @deauth, @event, @link, @unlink, @sync, @command, etc.
are <strong>datatypes</strong>
described for humans in
https://github.com/swimit/swim-proto-scala

SWIM has made RECON available in several programming languages:

   * https://github.com/swimit/recon-js
   * https://github.com/swimit/recon-scala
   * https://github.com/swimit/recon-java
   * https://github.com/swimit/recon-swift

Additionally, 

   * https://github.com/swimit/recon-sublime-syntax

   ~/Library/Application Support/Sublime Text 3
   Recon.sublime-syntax



<a name="Angular"></a>

## Angular directives #

The SWIM team 

https://github.com/swimit/swim-angular-js



## iOS App #

https://github.com/swimit/swim-todo-ios

The app makes use of Apple's Swift programming language 

https://github.com/swimit/swim-swift

Built by 
	<a target="_blank" href="https://www.ewanmellor.org/">
	San Francisco based freelance iOS developer</a>
Ewan Mellor
	(<a target="_blank" href="https://github.com/ewanmellor?tab=repositories">
	ewanmellor on GitHub</a>)


## Server run-time #

https://github.com/swimit/swimjs


https://github.com/swimit/swimjs/blob/master/API.md
contains the details



## Create To Do List client #

To-Do application

https://github.com/swimit/swim-todo-services



## Java #

https://github.com/swimit/swim-util-java

   * https://github.com/swimit/recon-java


## Rock stars #

By @c9r, Chris Sachs, chris@swim.it
https://github.com/c9r
https://www.linkedin.com/in/cdsachs
has built a Scala system before


## Companies #

DownlinkBuilder: an object used to constructor outbound links.

    URL ???


## Services #

Messaging

Fine grain control over privacy data

Intra-service and Inter-service introspection 


## Scalability #

Swim distributes the execution of Swim services across one or more clusters.


