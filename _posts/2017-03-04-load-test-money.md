---
layout: post
title: "Load test money"
excerpt: "Answers to why performance testing"
tags: [python, apple, mac, setup]
shorturl: "https://goo.gl/wNVxWD"
image:
# pic white python logo 1900x500.jpg
  feature: https://cloud.githubusercontent.com/assets/300046/14622164/4230c848-0585-11e6-957b-be11147346e6.jpg
  credit: 
  creditlink: 
comments: true
---
<i>{{ page.excerpt }}</i>
<hr />

{% include _toc.html %}

This is about the economics of performance testing and performance engineering work.

Spending money on performance testing is like companies paying for pre-employment drug tests --
drug testing inconveniences the vast majority of employees who don't use drugs
just because we don't want that one bad apple to devastate the others.

Just as there are several types of drugs potential employees can be using, 
there are different <strong>performance risks</strong> that may undermine enterprise systems.

1. Bad coding lurking in a specific line. Somewhere.

   For the same reason as 100% of candidates are made to take drug tests,
   the more coverage of functionality in performance tests, the more likely we are to find hidden issues.

   The most fundamental performance tests are done to identify how quickly servers respond
   to requests from customers and employees. The measurement is called
   <strong>response times</strong>.

2. Sometimes servers work until a certain level of work burns them out.

   Stress testing reveals the capacity of servers individually or as a group.

3. Sometimes .... memory leak.

4. Spike testing

5. Configuration testing

6. Resiliency testing

<hr />

1. What is the productivity of employees worth?

2. What would abandoned visitors have bought?

3. What is the company's reputation worth?

Risk

https://en.wikipedia.org/wiki/Software_performance_testing


### Load testing

Load testing is the simplest form of performance testing. A load test is usually conducted to understand the behaviour of the system under a specific expected load. This load can be the expected concurrent number of users on the application performing a specific number of transactions within the set duration. This test will give out the response times of all the important business critical transactions. The database, application server, etc. are also monitored during the test, this will assist in identifying bottlenecks in the application software and the hardware that the software is installed on.

### Stress testing

Stress testing is normally used to understand the upper limits of capacity within the system. This kind of test is done to determine the system's robustness in terms of extreme load and helps application administrators to determine if the system will perform sufficiently if the current load goes well above the expected maximum.

### Soak testing

Soak testing, also known as endurance testing, is usually done to determine if the system can sustain the continuous expected load. During soak tests, memory utilization is monitored to detect potential leaks. Also important, but often overlooked is performance degradation, i.e. to ensure that the throughput and/or response times after some long period of sustained activity are as good as or better than at the beginning of the test. It essentially involves applying a significant load to a system for an extended, significant period of time. The goal is to discover how the system behaves under sustained use.

Spike testing[edit]
Spike testing is done by suddenly increasing or decreasing the load generated by a very large number of users, and observing the behaviour of the system. The goal is to determine whether performance will suffer, the system will fail, or it will be able to handle dramatic changes in load.

Configuration testing[edit]
Rather than testing for performance from a load perspective, tests are created to determine the effects of configuration changes to the system's components on the system's performance and behaviour. A common example would be experimenting with different methods of load-balancing.

Isolation testing[edit]
Isolation testing is not unique to performance testing but involves repeating a test execution that resulted in a system problem. Such testing can often isolate and confirm the fault domain.