---
layout: post
title: "API JWT Authentication"
excerpt: "Authenticate like Google"
tags: [api, jwt, programming]
image:
# pic-clouds-blue-1900x500-60
  feature: https://cloud.githubusercontent.com/assets/300046/16578817/d09677b6-4259-11e6-909c-704d092a509c.jpg
  credit: 
  creditlink: 
comments: true
---
<i>{{ page.excerpt }}</i>
<hr />

{% include _toc.html %}

<a target="_blank" href="https://wilsonmar.github.io/awt-jwt/">https://wilsonmar.github.io/awt-jwt</a>

This tutorial examines how the JWT (JSON Web Token) authentication scheme works,
in a hands-on, step-by-step approach, with PROTIPs and NOTEs along the way.

<a target="_blank" href="https://en.wikipedia.org/wiki/JSON_Web_Token">
BTW, JWT is pronounced as "jot"</a>.

We begin below by manually using a <a href="#ManualDemo">
demo UI consuming service</a>
(Google's URL Shortener service 
because Google was an early adopter of JWT for all their APIs).

We examine the exchange of data between client and server as illustrated on
<a href="#MyDiagram">my diagram</a> 
of what happens behind the scenes
to generate JWT tokens.

The technical specification for JWT defined May 2015
by Internet Engineering Task Force (IETF) as 
<a target="_blank" href="https://tools.ietf.org/html/rfc7519.">
RFC 7519</a>
(<a target="_blank" href="http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html">
formatted</a> and
<a target="_blank" href="https://www.rfc-editor.org/info/rfc7519">PDF</a>).

NOTE: JWT is Updated by JWS (JSON Web Signatures) https://www.rfc-editor.org/info/rfc7797
that does not use Base64.

It emerged because the XML handling required by 
SAML (Security Asertion Markup Language) became too much for mobile devices.
JWT provides asymetric signing missing in the  
Simple Web Token standard created by Microsoft, Google, and Yahoo.


<a name="ManualDemo"></a>

## Demo UI consuming service #

<a target="_blank" href="http://jwt.io/">http://jwt.io</a>
generates JWT plus decodes and verifies JWT generated by others. 

As an introduction to how Google’s URL Shortener service works, 
let’s look at the human user interface which web services replace.

1.	Invoke a Google Chrome browser. If you do not have one installed, install it from
    <a target="_blank" href="http://google.com/chrome">http://google.com/chrome</a>

2.	Open an internet browser window to Google's URL Shortening service for individual Google users: 

    <a target="_blank" href="http://goo.gl/">http://goo.gl</a>

3.	Login using my Google account credentials.
    URLs shortened previous under your account should show up on the page:

    <amp-img width="650" height="379" alt="api-jwt-google-url-shortener-2016-06-30-650x379-63.jpg" 
    src="https://cloud.githubusercontent.com/assets/300046/16565704/501e5a3c-41cc-11e6-8b1a-337f58e886cc.jpg"></amp-img>

4.	Type or paste a URL in the text box and click the blue <strong>Shorten URL</strong> button. 

    Google takes the long URL pasted in the form and creates a SHORT URL from it.

5.	Use your mouse to highlight a goo.gl SHORT URL value to your Windows clipboard.

6.	Alt-click on a SHORT URL (in blue) to copy the URL link.

    You are taken to the URL.

<a target="_blank" href="https://support.google.com/faqs/answer/190768?hl=en">
This page at Google</a> notes that
"A unique short URL is created each time a long URL is shortened."
But if you were signed out,
the same short URL is reused each time a long URL is shortened by you or someone else.

What happened behind the scenes is illustrated at
the lower-left corner of the diagram below. 

<a name="MyDiagram"></a>

## Diagram # 

<amp-img width="650" height="431" alt="api-jwt-diagram-20160704-650x431-81.jpg" 
    src="https://cloud.githubusercontent.com/assets/300046/16565917/d9d60fa8-41cd-11e6-8e23-0732ba803f57.jpg">
    </amp-img>

Looking at the bottom left of the diagram (shown in red), 
we obtain a shortened URL in a JSON response to
submitting a long URL to shorten. 

The previous section describes this action on the goo.gl website.
But we are examining this so we can do it on our own client instead.

Either way, JavaScript in the client makes a call to the API end-point within the 
<a target="_blank" href="https://support.google.com/cloud/answer/3465889?hl=en&ref_topic=3340599">
Google Cloud Platform</a>:

    https://www.googleapis.com/urlshortener/v1/url 

The client makes the call after placing the URL to shorten in the <strong>body</strong> of the call
along with a <strong>AccessToken</strong> that the client obtained from another end-point:

    https://accounts.google.com/o/oauth2/token

The call to that was made by providing a <strong>JWT Assertion</strong> string obtained from
a call to a utility JWT library running on the client, providing credentials obtained
from Google based on the Google account which signed in (represented at the upper left). 

The gray area on the right side describes the internal processing typically done by the 
utility JWT library loaded on the client.
Other established libraries (such as OpenSSL) are called
to perform the complex math needed to sign signatures required by JWT.
This tutorial will later dive into the 
internal workings of these libraries. 

But first we need to look into obtaining inputs to those libraries from the
<a target="_blank" href="https://developers.google.com/console/help/?csw=1#generatingoauth2
"> Google Cloud Platform Console</a>.

The client making the call needs to have just four pieces of information needed to make the call:

1. The <strong>password</strong> "notasecret" (not a secret). 
   Why this still needs to be provided is a mystery to me because it 
   is always the same because secrecy now depends on cryptography
   provided by the next two items:

2. The service email for a specific API project looks like an email:

    <tt>123456789012@developer.gserviceaccount.com</tt>

3. The <strong>.p12 file fingerprint</strong>.   

4. How long the program allows access tokens to live.
   The Google API allows access tokens to live up to an hour. 
   Each organization may use a shorter time frame.

Next, let's look at this process.

## Get .p12 from Google API Console #

This is done to provide an example for the day when you'll use your own 
<strong>API management platform</strong> instead of this example.

0. Use an internet browser to go to the Google Developers Console at 
   <a target="_blank" href="https://console.developers.google.com/">
   https://console.developers.google.com/</a>

0. Sign-in with a company account or your own personal account.

    PROTIP: For testing production applications and their APIs, 
    testers normally obtain credentials from Security or DevOps personnel who 
    create separate company Google accounts which they then specify for Google to create Service accounts.

   The most popular APIs (among all Google users) is presented:
   <amp-img width="650" height="448" alt="api-google-popular-20160704-650x448-83.jpg"
    src="https://cloud.githubusercontent.com/assets/300046/16567212/30ae36ba-41d9-11e6-8675-ed6c73156281.jpg">
    </amp-img>

   <a href="#EnabledAPI">Click Enabled APIs</a> if you already have keys.<br /> 
   Otherwise:

0. First time visitors are asked to create a new project. Click on Create Project…. 

0. Google suggests a Project ID.

   PROTIP: Specify a version number after each project name.

0. Create a project from the Project Dashboard.

0. Type "shorten" in the gray search field.

0. Select "URL Shortener API" when it appears.

   PROTIP: Create a bookmark to this Developers Console for your sample URL Shortener API project.

   <a name="EnabledAPI"></a>

   ### Enabled APIs #

0. Click on "Credentials" on the left menu.

   A .p12 (private key) file named with the new fingerprint created is automatically downloaded. 
   
   BTW, “.p12” is a contraction of the file’s internal format being PKCS #12 
   among Public Key Cryptography Standards defined by RSA Laboratories at 
   https://www.rsa.com/rsalabs/node.asp?id=2138. 
   As explained in http://en.wikipedia.org/wiki/PKCS12, 
   “.p12” is the “Personal Information Exchange Syntax Standard".

   The private key password "notasecret" created by Google when the .p12 file was generated
   does not change because it is not used since the whole JWT mechanism is designed to 
   avoid sending passwords across the internet.

   Since the long name of the public key fingerprint file necessarily changes for each installation, 
   whatever file used is renamed to something like “484313????01.urlshortner.private.p12” 
   before being copied to the script folder.

   PROTIP: If you are doing this within an enterprise, corporate security people will have 
   likely defined naming conventions, procedures for safe storage, and policies for usage of key files. 
   An example of safe computing is to burn the .p12 and other such files onto a 
   DVD disk media kept in a fire-proof safe operated by Edward Snowden and one other person.

   A DVD is used because data on magnetic and solid-state hard drives can degrade over time. 
   Most secure organizations now have policies against use of USB drives.
   Physical possession of the private keys can be a complex discussion since the keys need to exist on computers.

## Signing #

Signing involves applying a known mathematical formula to a string such that it yields a set of numbers. 

Because the algorithm is rather complex, programs doing the signing usually make use of a 
library that contains functions to do the calculation. 

Making API calls using JWT requires the acquisition of a 
temporary access token which is valid for a short period of time. 
Google allows the amount of time to be determined by the caller, 
as long as it’s less than an hour. 

An access token (within parameter named “pAccessToken”) 
obtained from Google is added into the HTML header of the request. 
“Bearer” refers to the Bearer Token Usage standard 
http://tools.ietf.org/html/rfc6750 
which Google uses so cryptographic keys do not need to be sent over the network. 

Google wanted to use a more secure mechanism than users sending 
a password over an internet which can be snooped.

This means that applications and test scripts emulating applications 
need the logic to repeat access token requests when needed. 

### Sample 1 #

* https://github.com/kumartarun/JWT-with-Node-JS
   using jwt-simple/Crypto to create JWT token server side and
   passport.js to get into Twitter, Facebook, etc.

   <pre>
UserSchema.statics.encode = function(data) {
    return JWT.encode(data, CONSTANT.TOKEN_SECRET, 'HS256');
};
&nbsp;
UserSchema.statics.decode = function(data) {
    return JWT.decode(data, CONSTANT.TOKEN_SECRET);
};
   </pre>

### Sample 2 #

https://github.com/auth0/node-jsonwebtoken/
lists several algorthms to generate digital signatures
(HMAC using SHA-256 hash algorithm, etc.).
But the one used on the client needs to match what the server uses.

## Node implementation #

Sample code using that Node library is: 

   <pre>
// sign with default (HMAC SHA256)
var jwt = require('jsonwebtoken');
var token = jwt.sign({ foo: 'bar' }, 'shhhhh');
//backdate a jwt 30 seconds
var older_token = jwt.sign({ foo: 'bar', iat: Math.floor(Date.now() / 1000) - 30 }, 'shhhhh');
&nbsp;
// sign with RSA SHA256
var cert = fs.readFileSync('private.key');  // get private key
var token = jwt.sign({ foo: 'bar' }, cert, { algorithm: 'RS256'});
&nbsp;
// sign asynchronously
jwt.sign({ foo: 'bar' }, cert, { algorithm: 'RS256' }, function(err, token) {
  console.log(token);
});
   </pre>

Other implementations:

* https://www.youtube.com/watch?v=vziqErg6NZs
  https://vimeo.com/129702273
  Martin Gontovnikas
  (@mgonto, Dev Advocate from Argentina at Auth0)
  http://mgonto.github.io/apis-strike-back/
  
## Java Spring implementation #

